![img](https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_1440w.jpg)

![img](https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_1440w.jpg)

- 一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。
- 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。
- 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。
- 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。
- 静态成员变量跟随着类定义一起也存放在堆上。
- 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。

### 硬件内存架构

![img](https://pic1.zhimg.com/80/v2-67833188e191c5e7a11d34e613ca352c_1440w.jpg)

**CPU寄存器**，**高速缓存cache**，**内存**

通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。



多线程下的问题

- **缓存一致性问题**
- **指令重排序问题**

### Java内存模型和硬件内存架构之间的桥接

Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：

![img](https://pic3.zhimg.com/80/v2-1a7b7bb752799b6c067a0eaca0a1a9b2_1440w.jpg)

![img](https://pic3.zhimg.com/80/v2-037270b0876b6af680d1832bcc9dca32_1440w.jpg)



### JMM模型下的线程间通信

线程间通信必须经过主内存。

![img](https://pic2.zhimg.com/80/v2-8750cb14ecaa93509e3f1981563513e1_1440w.jpg)

1. 线程A把本地内存中更新过的共享变量刷新到主内存
2. 线程B从主内存中读取线程A更新过的共享变量

#### 主内存与工作内存之间的交互协议

主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- **unlock（解锁）**：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- **write（写入）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。



### JMM如何解决问题的

#### 多线程的读同步和可见性

##### 线程缓存导致的可见性问题

**可见性（共享对象可见性）**：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改

![img](https://pic2.zhimg.com/80/v2-7abd7500588012315f4f0e068e20e341_1440w.jpg)

###### 可见性解决方法

- **volatile**关键字

  volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。

- **synchronized**关键字

  - 对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
  - 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）

- **final**关键字

  被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）

##### 重排序导致的可见性问题

Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性

- **volatile**关键字

  本身就包含了禁止指令重排序的语义

- **synchronized**

  则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入

#### 多线程的写同步和原子性

![img](https://pic2.zhimg.com/80/v2-02ae4be429d4b48a18442efe91131155_1440w.jpg)

**同步块**解决：一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区，同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。